{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Serene is a minimalist readable systems programming language designed by Jamie Moschella ( @jammmo ). This site will walk you through the basic design of the language as well as several code examples. Serene is in the very early design stages right now, so there is no working compiler or full documentation yet, but the examples here should give you an idea of the direction that the language is headed. You can also check out the project on GitHub .","title":"Introduction"},{"location":"#introduction","text":"Serene is a minimalist readable systems programming language designed by Jamie Moschella ( @jammmo ). This site will walk you through the basic design of the language as well as several code examples. Serene is in the very early design stages right now, so there is no working compiler or full documentation yet, but the examples here should give you an idea of the direction that the language is headed. You can also check out the project on GitHub .","title":"Introduction"},{"location":"00_What_Is_Unique/","text":"What is Unique about Serene? \"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" -- Martin Fowler, 1999 Serene's biggest innovation is its memory management model. In general, most high level programming languages (like JavaScript, Python, and Java) use a tracing garbage collector, while systems programming languages have traditionally relied on manual memory management. Both approaches have their disadvantages: manual memory management is more complex from the programmer's perspective and is prone to small errors that can cause serious bugs, while tracing garbage collectors can introduce runtime overhead and unpredictability that are undesirable for systems programming. In recent years, a third approach has gained popularity: ownership. The idea of ownership, which was pioneered by the language Rust, is that each value is owned by only one variable at a given time. When that variable goes out of scope, the value will be automatically deleted. It allows for safe and predictable memory management without the need for intervention from the programmer or from an additional runtime process. However, for Rust's borrowing system to be as versatile as the extensive feature-set of a language like C++ required Rust to adopt a similarly large and complex range of features and rules, which has led some to say that the language has a \"high learning curve\". Serene takes inspiration from Rust's memory management system, but it aims to make ownership more straightforward. It does this by eliminating something that is a staple of most systems programming languages: Serene doesn't allow you to store references or pointers. There is no global sharing of state whatsoever -- each value is owned by only one variable at a given time, and it is only accessible through that variable . This may seem limiting, but if you imagine a program's memory as simply a large global array, and that a pointer is simply a index into that array, you can start to imagine alternate ways of recreating reference-like behavior without explicit pointers or references. The simplest way, which is adopted in Serene's Region and Handle system, is to split that global array into multiple local arrays, and to pass the arrays and indexes back and forth between functions when data needs to be shared. This effectively simulates region-based memory management. When a Serene object needs to reference another object, it can store an index, or Handle , to the Region that stores the other object. And unlike a local variable with a pointer, which is essentially a locally-stored index to a globally-stored array, both Handles and Regions are local, so no sharing of state is possible without passing parameters. Without pointers or references, program logic is much easier for a reader to follow, as you can clearly see whether any value is being mutated and where. In Serene, function parameters are passed immutably by default, but you can also create a function that will move , copy , or mutate its parameters, and there are keywords at both the definition site and calling site to make this behavior obvious. Serene's ownership model keeps the language simple and readable, while maintaining the low overhead and efficiency that is necessary for systems programming.","title":"What is Unique about Serene?"},{"location":"00_What_Is_Unique/#what-is-unique-about-serene","text":"\"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" -- Martin Fowler, 1999 Serene's biggest innovation is its memory management model. In general, most high level programming languages (like JavaScript, Python, and Java) use a tracing garbage collector, while systems programming languages have traditionally relied on manual memory management. Both approaches have their disadvantages: manual memory management is more complex from the programmer's perspective and is prone to small errors that can cause serious bugs, while tracing garbage collectors can introduce runtime overhead and unpredictability that are undesirable for systems programming. In recent years, a third approach has gained popularity: ownership. The idea of ownership, which was pioneered by the language Rust, is that each value is owned by only one variable at a given time. When that variable goes out of scope, the value will be automatically deleted. It allows for safe and predictable memory management without the need for intervention from the programmer or from an additional runtime process. However, for Rust's borrowing system to be as versatile as the extensive feature-set of a language like C++ required Rust to adopt a similarly large and complex range of features and rules, which has led some to say that the language has a \"high learning curve\". Serene takes inspiration from Rust's memory management system, but it aims to make ownership more straightforward. It does this by eliminating something that is a staple of most systems programming languages: Serene doesn't allow you to store references or pointers. There is no global sharing of state whatsoever -- each value is owned by only one variable at a given time, and it is only accessible through that variable . This may seem limiting, but if you imagine a program's memory as simply a large global array, and that a pointer is simply a index into that array, you can start to imagine alternate ways of recreating reference-like behavior without explicit pointers or references. The simplest way, which is adopted in Serene's Region and Handle system, is to split that global array into multiple local arrays, and to pass the arrays and indexes back and forth between functions when data needs to be shared. This effectively simulates region-based memory management. When a Serene object needs to reference another object, it can store an index, or Handle , to the Region that stores the other object. And unlike a local variable with a pointer, which is essentially a locally-stored index to a globally-stored array, both Handles and Regions are local, so no sharing of state is possible without passing parameters. Without pointers or references, program logic is much easier for a reader to follow, as you can clearly see whether any value is being mutated and where. In Serene, function parameters are passed immutably by default, but you can also create a function that will move , copy , or mutate its parameters, and there are keywords at both the definition site and calling site to make this behavior obvious. Serene's ownership model keeps the language simple and readable, while maintaining the low overhead and efficiency that is necessary for systems programming.","title":"What is Unique about Serene?"},{"location":"01_Functions/","text":"1. Functions Every program in Serene is required to have a main function. Here is a basic example of a main function that prints \"Hello world!\" on a new line. function main () { run printLine( \"Hello world!\" ) } Here, \"Hello world!\" is being passed as a parameter to the printLine function. Let's define another function that takes a parameter and also returns a value. Note that the types of both the parameters and return values must be specified. function invert (b: Bool ) -> Bool { return (not b) }","title":"1. Functions"},{"location":"01_Functions/#1-functions","text":"Every program in Serene is required to have a main function. Here is a basic example of a main function that prints \"Hello world!\" on a new line. function main () { run printLine( \"Hello world!\" ) } Here, \"Hello world!\" is being passed as a parameter to the printLine function. Let's define another function that takes a parameter and also returns a value. Note that the types of both the parameters and return values must be specified. function invert (b: Bool ) -> Bool { return (not b) }","title":"1. Functions"},{"location":"02_Variables_Types_And_Math/","text":"2. Variables, Types, and Math A new variable can be created with either the keyword const (short for \"constant\") or the keyword var (short for \"variable\"). function test1 () { const age: Int = 20 run printLine(age) // age can't be changed here! } function test2 () { var age: Int = 20 run printLine(age) set age = 21 run printLine(age) set age = age + 1 run printLine(age) set age += 1 // same as: set age = age + 1 run printLine(age) } function test3 () { const base = 5 //the type Int is implied here const height = 8 const area: Float = (1/2) * base * height run printLine(area, \" inches\" ) } function test4 () { var name: String = \"Rick Astley\" set name = \"Rickroll\" //strings are mutable run printLine(name) }","title":"2. Variables, Types, and Math"},{"location":"02_Variables_Types_And_Math/#2-variables-types-and-math","text":"A new variable can be created with either the keyword const (short for \"constant\") or the keyword var (short for \"variable\"). function test1 () { const age: Int = 20 run printLine(age) // age can't be changed here! } function test2 () { var age: Int = 20 run printLine(age) set age = 21 run printLine(age) set age = age + 1 run printLine(age) set age += 1 // same as: set age = age + 1 run printLine(age) } function test3 () { const base = 5 //the type Int is implied here const height = 8 const area: Float = (1/2) * base * height run printLine(area, \" inches\" ) } function test4 () { var name: String = \"Rick Astley\" set name = \"Rickroll\" //strings are mutable run printLine(name) }","title":"2. Variables, Types, and Math"},{"location":"03_Mutability_And_Ownership/","text":"3. Mutability and Ownership All values in Serene are owned by a single variable. function middleChar (s: String , mutate c: Char ) { // Find the character at the middle index of a string const length = s.length const middle = Int(length / 2) set c = s[middle] } function removeChar ( mutate s: String , c: Char ) { // Remove all instances of a character in a string var i = 0 while (i < s.length) { if (s[i] == c) { run s.delete(i) } else { set i += 1 } } } function main () { const name = \"Matthew\" var letter = Char( ' ' ) run middleChar(name, mutate letter) var newname = name //copies name run removeChar( mutate newname, c) }","title":"3. Mutability and Ownership"},{"location":"03_Mutability_And_Ownership/#3-mutability-and-ownership","text":"All values in Serene are owned by a single variable. function middleChar (s: String , mutate c: Char ) { // Find the character at the middle index of a string const length = s.length const middle = Int(length / 2) set c = s[middle] } function removeChar ( mutate s: String , c: Char ) { // Remove all instances of a character in a string var i = 0 while (i < s.length) { if (s[i] == c) { run s.delete(i) } else { set i += 1 } } } function main () { const name = \"Matthew\" var letter = Char( ' ' ) run middleChar(name, mutate letter) var newname = name //copies name run removeChar( mutate newname, c) }","title":"3. Mutability and Ownership"},{"location":"04_Collections/","text":"4. Collections In this section, we will learn about several more complex types that are built into Serene. Arrays An array is a fixed-length sequence elements, where all of the elements are the same type. Indexing an array always returns an Optional, because the index used may be outside of the valid range of indexes. If the index is invalid, the indexing operation will return undefined . function binarySearch (u: Array [Int], x: Int ) -> Int { var i = u.length / 2 while (True) { either (u[i] is defined) or throw IndexError if (u[i] < x) { set i = i / 2 } elseif (u[i] > x) { set i = (i + u.length)/2 } else { return i } } } //Where is the maybe-checking? Vectors An vector is similar to an array, except its length can be changed after creation. Like an array, if the index is invalid, the indexing operation will return undefined . function binarySearchAndDelete ( mutate u: Array [Int], x: Int ) { var i = u.length / 2 while (True) { if (u[i] < x) { set i = i / 2 } elseif (u[i] > x) { set i = (i + u.length)/2 } else { u.delete!(i) } } } //Where is the maybe-checking? Regions (and Handles) A Region is a dynamically-sized block of memory where objects of the same type can be stored. Those objects are accessed using an index, referred to as a Handle. You can think of a Region as somewhat similar to a hash map, as it is effectively a mapping of keys to values. But unlike a hash map, the keys, called Handles in this case, are a special opaque type and are assigned by the Region when new values are added, rather than being assigned by the programmer. Once again, if the Handle doesn't refer to a valid object, the indexing operation will return undefined . Regions and Handles may sound a bit odd right now, but you'll see why they are necessary once you learn how to define your own types. For now, here is a simple demonstration of how they work. function makeNames () { var reg = Region[String] const firstName = reg.add!( \"Neil\" ) const middleName = reg.add!( \"Patrick\" ) const lastName = reg.add!( \"Harris\" ) printLine(reg[firstName]) printLine(reg[middleName]) printLine(reg[lastName]) } // This function isn't useful, as the strings won't be accessible from the calling scope // but will still occupy memory within the Region. However, it's not a memory leak, because // reg as a whole is still accessible and can be deallocated later. function makeNames2 () -> Region[String] { var reg = Region[String] const firstName = reg.add!( \"Neil\" ) const middleName = reg.add!( \"Patrick\" ) const lastName = reg.add!( \"Harris\" ) return reg }","title":"4. Collections"},{"location":"04_Collections/#4-collections","text":"In this section, we will learn about several more complex types that are built into Serene.","title":"4. Collections"},{"location":"04_Collections/#arrays","text":"An array is a fixed-length sequence elements, where all of the elements are the same type. Indexing an array always returns an Optional, because the index used may be outside of the valid range of indexes. If the index is invalid, the indexing operation will return undefined . function binarySearch (u: Array [Int], x: Int ) -> Int { var i = u.length / 2 while (True) { either (u[i] is defined) or throw IndexError if (u[i] < x) { set i = i / 2 } elseif (u[i] > x) { set i = (i + u.length)/2 } else { return i } } } //Where is the maybe-checking?","title":"Arrays"},{"location":"04_Collections/#vectors","text":"An vector is similar to an array, except its length can be changed after creation. Like an array, if the index is invalid, the indexing operation will return undefined . function binarySearchAndDelete ( mutate u: Array [Int], x: Int ) { var i = u.length / 2 while (True) { if (u[i] < x) { set i = i / 2 } elseif (u[i] > x) { set i = (i + u.length)/2 } else { u.delete!(i) } } } //Where is the maybe-checking?","title":"Vectors"},{"location":"04_Collections/#regions-and-handles","text":"A Region is a dynamically-sized block of memory where objects of the same type can be stored. Those objects are accessed using an index, referred to as a Handle. You can think of a Region as somewhat similar to a hash map, as it is effectively a mapping of keys to values. But unlike a hash map, the keys, called Handles in this case, are a special opaque type and are assigned by the Region when new values are added, rather than being assigned by the programmer. Once again, if the Handle doesn't refer to a valid object, the indexing operation will return undefined . Regions and Handles may sound a bit odd right now, but you'll see why they are necessary once you learn how to define your own types. For now, here is a simple demonstration of how they work. function makeNames () { var reg = Region[String] const firstName = reg.add!( \"Neil\" ) const middleName = reg.add!( \"Patrick\" ) const lastName = reg.add!( \"Harris\" ) printLine(reg[firstName]) printLine(reg[middleName]) printLine(reg[lastName]) } // This function isn't useful, as the strings won't be accessible from the calling scope // but will still occupy memory within the Region. However, it's not a memory leak, because // reg as a whole is still accessible and can be deallocated later. function makeNames2 () -> Region[String] { var reg = Region[String] const firstName = reg.add!( \"Neil\" ) const middleName = reg.add!( \"Patrick\" ) const lastName = reg.add!( \"Harris\" ) return reg }","title":"Regions (and Handles)"},{"location":"05_Control_Flow/","text":"5. Control Flow So far, we have learned several key components to how programs are structured in Serene. However, it would be hard to implement anything practical with only what we have shown so far, as we haven't shown much of the logic necessary for describing any form of procedure. Here we discuss the control flow constructs that enable us to write practical programs. Conditional Statements A conditional statement (or an if/else statement) allows a program to check a condition and do something different based on the value of that condition. function absoluteValue (x: Int ) { if (x < 0) { return -x } else { return x } } Loops Serene has two looping constructs: For Loops and While Loops. function findMax (u: Vector [Int]) -> Int { var max: Int = INT_MIN for (x in u) { if (x > max) { set max = x } } } function findMax2 (u: Vector [Int]) -> Int { var max: Int = INT_MIN var i: Int = 0 while (i < u.length) { if (u[i] > max) { // Do you need to check if u[i] is None? set max = u[i] } } } Match A Match statement takes a single object as its parameter and it allows you to write multiple paths of execution based on the value of the object. function makeChoice () -> Bool { while (True) { var input = ReadLine() match (input) { \"\" -> continue \"y\", \"Y\" -> return True \"n\", \"N\" -> return False else -> { run printLine( \"Input is invalid, try again\" ) continue } } } } More Control Flow There is one more control flow construct in Serene, named either . But there's a bit of background explanation as to why either is necessary, so you can explore that in the next section.","title":"5. Control Flow"},{"location":"05_Control_Flow/#5-control-flow","text":"So far, we have learned several key components to how programs are structured in Serene. However, it would be hard to implement anything practical with only what we have shown so far, as we haven't shown much of the logic necessary for describing any form of procedure. Here we discuss the control flow constructs that enable us to write practical programs.","title":"5. Control Flow"},{"location":"05_Control_Flow/#conditional-statements","text":"A conditional statement (or an if/else statement) allows a program to check a condition and do something different based on the value of that condition. function absoluteValue (x: Int ) { if (x < 0) { return -x } else { return x } }","title":"Conditional Statements"},{"location":"05_Control_Flow/#loops","text":"Serene has two looping constructs: For Loops and While Loops. function findMax (u: Vector [Int]) -> Int { var max: Int = INT_MIN for (x in u) { if (x > max) { set max = x } } } function findMax2 (u: Vector [Int]) -> Int { var max: Int = INT_MIN var i: Int = 0 while (i < u.length) { if (u[i] > max) { // Do you need to check if u[i] is None? set max = u[i] } } }","title":"Loops"},{"location":"05_Control_Flow/#match","text":"A Match statement takes a single object as its parameter and it allows you to write multiple paths of execution based on the value of the object. function makeChoice () -> Bool { while (True) { var input = ReadLine() match (input) { \"\" -> continue \"y\", \"Y\" -> return True \"n\", \"N\" -> return False else -> { run printLine( \"Input is invalid, try again\" ) continue } } } }","title":"Match"},{"location":"05_Control_Flow/#more-control-flow","text":"There is one more control flow construct in Serene, named either . But there's a bit of background explanation as to why either is necessary, so you can explore that in the next section.","title":"More Control Flow"},{"location":"06_Expressing_Nothing/","text":"6. Expressing Nothing There are a couple ways of expressing that something does not exist in Serene. Maybe (Defined and Undefined) The keywords defined and undefined are used primarily for checking whether an index into some collection (like a vector or a region) is valid. While the language Python, for example, throws an IndexError at runtime when an invalid index is accessed, Serene returns undefined . The compiler requires you to check for these undefined values, which allows common errors to be caught at compile time (using \"type refinement\") instead of at runtime. Checking whether a value is defined is often done with either statement, which will be introduced below. An important note is that defined and undefined technically aren't values. This makes them different from null pointers in C or Option in Rust. You can have a function return a value that might be undefined by prefixing the return type with maybe , but function parameters cannot be undefined. Also, once you have checked that a value is defined, you can continue to use it like any other value: there is no \"unwrapping\" necessary. function getFirst (u: String ) -> maybe Char { if (u.length > 0) { return u[0] } else { return undefined } } Either The either statement is used to handle values that may be undefined. Here is an example of using the indexing operator with a Handle . either will try to execute the statement in parentheses, and if any part of it returns undefined , then it will stop executing that statement (in this case, it would stop without mutating currentObject ) and it would instead execute the second statement, after the keyword or . // Assume that the LinkedList struct redirects its subscripting to LinkedList.objects function findTail (u: LinkedList ) -> maybe Handle { either ( var currentObject = u[u.head]) or return undefined while (True) { var currentIndex = currentObject.next either ( set currentObject = L[currentIndex]) or return currentIndex } } function removeTail ( mutate u: LinkedList ) { either ( var currentObject = u[u.head]) or return //This copies u[u.head] so it might not be efficient while (True) { var currentIndex = currentObject.next either ( set currentObject = u[currentIndex]) or break } run u.delete!(currentIndex) //methods that mutate the object are called with a \"!\" } Cell While it isn't present for maybe types, the \"unwrapping\" behavior of something like Option in Rust is still useful in certain situations. For that, Serene provides the Cell type, which can be unwrapped into either Some(x) or Empty .","title":"6. Expressing Nothing"},{"location":"06_Expressing_Nothing/#6-expressing-nothing","text":"There are a couple ways of expressing that something does not exist in Serene.","title":"6. Expressing Nothing"},{"location":"06_Expressing_Nothing/#maybe-defined-and-undefined","text":"The keywords defined and undefined are used primarily for checking whether an index into some collection (like a vector or a region) is valid. While the language Python, for example, throws an IndexError at runtime when an invalid index is accessed, Serene returns undefined . The compiler requires you to check for these undefined values, which allows common errors to be caught at compile time (using \"type refinement\") instead of at runtime. Checking whether a value is defined is often done with either statement, which will be introduced below. An important note is that defined and undefined technically aren't values. This makes them different from null pointers in C or Option in Rust. You can have a function return a value that might be undefined by prefixing the return type with maybe , but function parameters cannot be undefined. Also, once you have checked that a value is defined, you can continue to use it like any other value: there is no \"unwrapping\" necessary. function getFirst (u: String ) -> maybe Char { if (u.length > 0) { return u[0] } else { return undefined } }","title":"Maybe (Defined and Undefined)"},{"location":"06_Expressing_Nothing/#either","text":"The either statement is used to handle values that may be undefined. Here is an example of using the indexing operator with a Handle . either will try to execute the statement in parentheses, and if any part of it returns undefined , then it will stop executing that statement (in this case, it would stop without mutating currentObject ) and it would instead execute the second statement, after the keyword or . // Assume that the LinkedList struct redirects its subscripting to LinkedList.objects function findTail (u: LinkedList ) -> maybe Handle { either ( var currentObject = u[u.head]) or return undefined while (True) { var currentIndex = currentObject.next either ( set currentObject = L[currentIndex]) or return currentIndex } } function removeTail ( mutate u: LinkedList ) { either ( var currentObject = u[u.head]) or return //This copies u[u.head] so it might not be efficient while (True) { var currentIndex = currentObject.next either ( set currentObject = u[currentIndex]) or break } run u.delete!(currentIndex) //methods that mutate the object are called with a \"!\" }","title":"Either"},{"location":"06_Expressing_Nothing/#cell","text":"While it isn't present for maybe types, the \"unwrapping\" behavior of something like Option in Rust is still useful in certain situations. For that, Serene provides the Cell type, which can be unwrapped into either Some(x) or Empty .","title":"Cell"},{"location":"07_Custom_Types/","text":"7. Custom Types Types in Serene can be defined using the type keyword, as shown below. Serene supports multiple forms of \"compound types\", including structs, enums, and tuples. type Person struct { age: Int , name: String , gender: enum { Male, Female }, nickname: enum { Some (String), None }, } type Point3D tuple { Int, Int, Int } type Address tuple { Int, // House number String, // Street name } type RainbowColors enum { Red, Orange, Yellow, Green, Blue, Purple } Linked List Example Here is an example of a singly linked list implementation in Serene. Notice here that the definition of the LinkedList type has multiple parts to it: a struct, a constructor, and specifics. The struct is the \"format\" of the data that is stored within the type (it can also be an enum or tuple), while the constructor initializes the struct to actual values. specifics is used to implement methods that can be called on this type. When a type definition has multiple parts like this, each part begins with a tilde ( ~ ), and they are meant to look like a bulleted list of details about the type. // Linked list of integers type Node( type N) struct { data: Int , next: N , } type LinkedList with ~ struct { nodes: Region [Node[Int]], head: Cell [Handle], } ~ constructor(first: Int ) { type Handle = nodes.Handle set head = nodes.add!(Node(first, None)) } ~ specifics { method addFirst (a: Int ) { set head = nodes.add!(Node(a, head)) } method addLast (a: Int ) { if (head is Empty) { set head = nodes.add!(Node(a, None)) } else { var x = nodes[head] while (nodes[x.next] is defined) { set x = nodes[x.next] } set x.next = nodes.add!(Node(a, None)) } } method deleteFirst () { if (head is Empty) return const x = head set head = nodes[head].next run nodes.delete!(x) } method deleteLast () { if (head is Empty) return var x = nodes[head] while (nodes[x.next] is defined) { set x = nodes[x.next] } run nodes.delete!(x) } subscript get (MyHandle: Handle ) -> maybe Int { return nodes[MyHandle] } }","title":"7. Custom Types"},{"location":"07_Custom_Types/#7-custom-types","text":"Types in Serene can be defined using the type keyword, as shown below. Serene supports multiple forms of \"compound types\", including structs, enums, and tuples. type Person struct { age: Int , name: String , gender: enum { Male, Female }, nickname: enum { Some (String), None }, } type Point3D tuple { Int, Int, Int } type Address tuple { Int, // House number String, // Street name } type RainbowColors enum { Red, Orange, Yellow, Green, Blue, Purple }","title":"7. Custom Types"},{"location":"07_Custom_Types/#linked-list-example","text":"Here is an example of a singly linked list implementation in Serene. Notice here that the definition of the LinkedList type has multiple parts to it: a struct, a constructor, and specifics. The struct is the \"format\" of the data that is stored within the type (it can also be an enum or tuple), while the constructor initializes the struct to actual values. specifics is used to implement methods that can be called on this type. When a type definition has multiple parts like this, each part begins with a tilde ( ~ ), and they are meant to look like a bulleted list of details about the type. // Linked list of integers type Node( type N) struct { data: Int , next: N , } type LinkedList with ~ struct { nodes: Region [Node[Int]], head: Cell [Handle], } ~ constructor(first: Int ) { type Handle = nodes.Handle set head = nodes.add!(Node(first, None)) } ~ specifics { method addFirst (a: Int ) { set head = nodes.add!(Node(a, head)) } method addLast (a: Int ) { if (head is Empty) { set head = nodes.add!(Node(a, None)) } else { var x = nodes[head] while (nodes[x.next] is defined) { set x = nodes[x.next] } set x.next = nodes.add!(Node(a, None)) } } method deleteFirst () { if (head is Empty) return const x = head set head = nodes[head].next run nodes.delete!(x) } method deleteLast () { if (head is Empty) return var x = nodes[head] while (nodes[x.next] is defined) { set x = nodes[x.next] } run nodes.delete!(x) } subscript get (MyHandle: Handle ) -> maybe Int { return nodes[MyHandle] } }","title":"Linked List Example"},{"location":"08_Interfaces/","text":"8. Interfaces When writing a function, sometimes you only care about what methods the function arguments support, and not how they're implemented. You may want to write the function in a flexible way so that they can accept any type that implements the correct methods. That can be done with Interfaces. Here is an example of how you can define an Interface. import AddressModule interface Card with ~ struct { returnAddress: String } interface Invitation with ~ struct { date: String , location: Address , numGuests: Int , accepted: Bool } ~ signatures { method send (recipient: Person ), method accept (guests: Int ) } type WeddingInvitation with ~ struct { bride: String , groom: String , struct from Invitation, struct from Card } ~ specifics (implements Invitation) { method send (recipient: Person ) { run recipient.receive( copy self) } method accept (guests: Int ) { set self.accepted = True } method parseLocation (address: String ) from AddressModule } // Interfaces with generics? interface CompareAndIndex(self: type X) with ~ signatures { method lessThan (other: X ) -> bool method greaterThan (other: X ) -> bool subscript get (index: Int ) -> Option(X) } ~ specifics where X: Array [Int] { method lessThan (other: Array [Int]) { for (i = 0, min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] < other[i] } } return self.length < other.length } method lessThan (other: Array [Int]) { for (i = 0, min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] > other[i] } } return self.length > other.length } subscript get (index: Int ) -> Optional[Int] from Index(self: Array [ type X]) }","title":"8. Interfaces"},{"location":"08_Interfaces/#8-interfaces","text":"When writing a function, sometimes you only care about what methods the function arguments support, and not how they're implemented. You may want to write the function in a flexible way so that they can accept any type that implements the correct methods. That can be done with Interfaces. Here is an example of how you can define an Interface. import AddressModule interface Card with ~ struct { returnAddress: String } interface Invitation with ~ struct { date: String , location: Address , numGuests: Int , accepted: Bool } ~ signatures { method send (recipient: Person ), method accept (guests: Int ) } type WeddingInvitation with ~ struct { bride: String , groom: String , struct from Invitation, struct from Card } ~ specifics (implements Invitation) { method send (recipient: Person ) { run recipient.receive( copy self) } method accept (guests: Int ) { set self.accepted = True } method parseLocation (address: String ) from AddressModule } // Interfaces with generics? interface CompareAndIndex(self: type X) with ~ signatures { method lessThan (other: X ) -> bool method greaterThan (other: X ) -> bool subscript get (index: Int ) -> Option(X) } ~ specifics where X: Array [Int] { method lessThan (other: Array [Int]) { for (i = 0, min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] < other[i] } } return self.length < other.length } method lessThan (other: Array [Int]) { for (i = 0, min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] > other[i] } } return self.length > other.length } subscript get (index: Int ) -> Optional[Int] from Index(self: Array [ type X]) }","title":"8. Interfaces"},{"location":"09_Generic_Functions/","text":"9. Generic Functions Serene supports both generic functions and generic types. A generic parameter is specified using the type keyword, like in the example below. function elementInArray ( move elem: type T, arr: Array [ type T]) -> maybe type T { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } // Where statement function elementInArray ( move elem: type A, arr: type B) -> maybe type A where type A: Simple , type B: Array [A] { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } // Idea: plug in type variable to function instead of value to yield return type? // Potentially some ambiguity/confusion there but definitely useful // Is \"type\" needed everywhere in the signature or only the first time the name is referenced?","title":"9. Generic Functions"},{"location":"09_Generic_Functions/#9-generic-functions","text":"Serene supports both generic functions and generic types. A generic parameter is specified using the type keyword, like in the example below. function elementInArray ( move elem: type T, arr: Array [ type T]) -> maybe type T { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } // Where statement function elementInArray ( move elem: type A, arr: type B) -> maybe type A where type A: Simple , type B: Array [A] { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return undefined } // Idea: plug in type variable to function instead of value to yield return type? // Potentially some ambiguity/confusion there but definitely useful // Is \"type\" needed everywhere in the signature or only the first time the name is referenced?","title":"9. Generic Functions"},{"location":"10_Generic_Types/","text":"10. Generic Types We will introduce generic types through an example using Regions and Handles, two commonly used built-in types. Regions and Handles Serene does not have references or pointers. So how does one object refer to another object? The idiom that is most commonly used in Serene is region-based memory management, with the types Region and Handle . If you have a bunch of objects of the same type that all refer to each other (say, in a data structure like a linked list), then the typical way to handle it is to store all of the objects inside one Region . Then an object can access another object by storing its Handle in one of its fields. The other object would be accessed with an indexing operator, like my_region[my_handle] . Note that the indexing operator returns an Option type here because it is possible that there is no valid object for that handle. Below is a reference implementation of the Region and Handle types. // Potential implementation of the Region and Handle system as a standard library module type Handle with ~ constructor( type MyRegion, index: Int ) { set index = index } ~ struct { index: Int private } ~ friend Region // Handle has two parameters here, but only one is needed for the generic? type Region with ~ constructor( type T) { set vector = Vector[T] type R = typeof(self) } ~ struct { vector: Vector [T] private, } ~ specifics { method add (new_value: T ) -> Handle[R] { run vector.append(NewValue) const handle = Handle(Region, vector.length) return handle } method delete (index_to_delete: Handle [R]) { run vector.pop!(index_to_delete) } subscript get (my_handle: Handle [R]) -> maybe T { return vector[my_handle.index] } } // Note that all T's here are the same and they come from the constructor. Need a better way to make that clear...","title":"10. Generic Types"},{"location":"10_Generic_Types/#10-generic-types","text":"We will introduce generic types through an example using Regions and Handles, two commonly used built-in types.","title":"10. Generic Types"},{"location":"10_Generic_Types/#regions-and-handles","text":"Serene does not have references or pointers. So how does one object refer to another object? The idiom that is most commonly used in Serene is region-based memory management, with the types Region and Handle . If you have a bunch of objects of the same type that all refer to each other (say, in a data structure like a linked list), then the typical way to handle it is to store all of the objects inside one Region . Then an object can access another object by storing its Handle in one of its fields. The other object would be accessed with an indexing operator, like my_region[my_handle] . Note that the indexing operator returns an Option type here because it is possible that there is no valid object for that handle. Below is a reference implementation of the Region and Handle types. // Potential implementation of the Region and Handle system as a standard library module type Handle with ~ constructor( type MyRegion, index: Int ) { set index = index } ~ struct { index: Int private } ~ friend Region // Handle has two parameters here, but only one is needed for the generic? type Region with ~ constructor( type T) { set vector = Vector[T] type R = typeof(self) } ~ struct { vector: Vector [T] private, } ~ specifics { method add (new_value: T ) -> Handle[R] { run vector.append(NewValue) const handle = Handle(Region, vector.length) return handle } method delete (index_to_delete: Handle [R]) { run vector.pop!(index_to_delete) } subscript get (my_handle: Handle [R]) -> maybe T { return vector[my_handle.index] } } // Note that all T's here are the same and they come from the constructor. Need a better way to make that clear...","title":"Regions and Handles"},{"location":"11_Modules/","text":"11. Modules It is extremely helpful to be able to use well-tested existing pieces of code to implement common functionality, or to be able to split your own code into multiple files for organization. Modules allow you to do just that. Like most programming languages, Serene is packaged with a standard library that implements many common functions and datatypes so you don't have to implement them yourself. You can use import statements to control what external modules you want to use. Import statements also allow you to import modules that you have created yourself, by using a relative file path to the module's location. Standard Imports import Math import AsyncGUI.window as window Local Imports import local \"lib/MovieReviewTypes.sn\"","title":"11. Modules"},{"location":"11_Modules/#11-modules","text":"It is extremely helpful to be able to use well-tested existing pieces of code to implement common functionality, or to be able to split your own code into multiple files for organization. Modules allow you to do just that. Like most programming languages, Serene is packaged with a standard library that implements many common functions and datatypes so you don't have to implement them yourself. You can use import statements to control what external modules you want to use. Import statements also allow you to import modules that you have created yourself, by using a relative file path to the module's location.","title":"11. Modules"},{"location":"11_Modules/#standard-imports","text":"import Math import AsyncGUI.window as window","title":"Standard Imports"},{"location":"11_Modules/#local-imports","text":"import local \"lib/MovieReviewTypes.sn\"","title":"Local Imports"},{"location":"99_Everything_Else/","text":"Everything Else Clearly, the topics described up to this point don't exhaust every feature necessary for a modern systems programming language. This is simply what has been designed so far. So what other features are planned for Serene? Concurrency This is an important one, and it's probably the biggest unknown at this point. Hardware Interrupts Just like with concurrency, I think it makes sense for the compiler to have some sort of awareness of hardware interrupts. Interrupts don't come up in regular application-level programming, but they're essential to embedded programming. In C, programming interrupt service routines often involves mutating global variables that are declared volatile , but in Serene that would completely break the safety and \"sanity\" of the ownership system. So there should be some way of registering interrupts in a program so that both the reader and the compiler can clearly tell where they are enabled, and so that state is passed safely between the local scope and the interrupt service routine's scope. Error Handling Error handling isn't the most exciting aspect of a language, but for a language to promote safety and reliability, it needs a good error handling system. Anonymous Functions With function parameters being immutable by default and the language having no global mutable state, Serene has a decent amount in common with functional programming languages. While Serene is intended to be used in a procedural style, it should at least be possible to mimic a functional style when it suits the problem you are trying to solve. Tuning From the examples here, it might be hard to see how Serene is a systems programming language. The base language doesn't expose any control over how data is laid out in memory. While there are no explicit pointers, you can imagine there will be a lot of references and heap allocations involved under-the-hood in creating something like a Region of Vectors, considering both types are dynamically sized. How can a language like this hope to be as fast as C or Rust? For starters, the language's strict ownership system will allow for aggressive compiler optimization. But for more precise control, there will also be a system of pragmas and annotations for \"tuning\" your code's performance. While optimizing memory usage in C can involve major structural changes to your code and the potential to reintroduce bugs, the tuning system won't get in the way of business logic. Instead, it will allow you to adjust compiler parameters related to memory and performance for individual functions and types, and it will allow you to set constraints for yourself to \"ban\" certain operations that are inefficient. A design principle of the language is that performance should be orthogonal to correctness . While manual memory management allows more control over performance, its complexity can lead to bugs. Serene's simple but strict semantics make correctness easy to accomplish, and by allowing independent control of performance parameters, you can experiment with optimizing your code with little risk of breaking it. Standard Library Of course, any good programming language needs a good standard library. Many Other Things Serene was intended from the beginning to be a \"small language\", and I plan on limiting the features to only what is necessary. That said, you could probably make a case that many things I haven't listed here are necessary. Programming languages generally seem to \"grow\" over time as people demand more features. The initial Serene compiler will likely start out with a very minimalist featureset, possibly even smaller than what I've shown in the previous sections. And if people start using it, they will almost certainly discover things that aren't possible or ergonomic with the existing features, so the language will need to adapt to address any shortcomings while hopefully keeping its original design intentions intact.","title":"Everything Else"},{"location":"99_Everything_Else/#everything-else","text":"Clearly, the topics described up to this point don't exhaust every feature necessary for a modern systems programming language. This is simply what has been designed so far. So what other features are planned for Serene?","title":"Everything Else"},{"location":"99_Everything_Else/#concurrency","text":"This is an important one, and it's probably the biggest unknown at this point.","title":"Concurrency"},{"location":"99_Everything_Else/#hardware-interrupts","text":"Just like with concurrency, I think it makes sense for the compiler to have some sort of awareness of hardware interrupts. Interrupts don't come up in regular application-level programming, but they're essential to embedded programming. In C, programming interrupt service routines often involves mutating global variables that are declared volatile , but in Serene that would completely break the safety and \"sanity\" of the ownership system. So there should be some way of registering interrupts in a program so that both the reader and the compiler can clearly tell where they are enabled, and so that state is passed safely between the local scope and the interrupt service routine's scope.","title":"Hardware Interrupts"},{"location":"99_Everything_Else/#error-handling","text":"Error handling isn't the most exciting aspect of a language, but for a language to promote safety and reliability, it needs a good error handling system.","title":"Error Handling"},{"location":"99_Everything_Else/#anonymous-functions","text":"With function parameters being immutable by default and the language having no global mutable state, Serene has a decent amount in common with functional programming languages. While Serene is intended to be used in a procedural style, it should at least be possible to mimic a functional style when it suits the problem you are trying to solve.","title":"Anonymous Functions"},{"location":"99_Everything_Else/#tuning","text":"From the examples here, it might be hard to see how Serene is a systems programming language. The base language doesn't expose any control over how data is laid out in memory. While there are no explicit pointers, you can imagine there will be a lot of references and heap allocations involved under-the-hood in creating something like a Region of Vectors, considering both types are dynamically sized. How can a language like this hope to be as fast as C or Rust? For starters, the language's strict ownership system will allow for aggressive compiler optimization. But for more precise control, there will also be a system of pragmas and annotations for \"tuning\" your code's performance. While optimizing memory usage in C can involve major structural changes to your code and the potential to reintroduce bugs, the tuning system won't get in the way of business logic. Instead, it will allow you to adjust compiler parameters related to memory and performance for individual functions and types, and it will allow you to set constraints for yourself to \"ban\" certain operations that are inefficient. A design principle of the language is that performance should be orthogonal to correctness . While manual memory management allows more control over performance, its complexity can lead to bugs. Serene's simple but strict semantics make correctness easy to accomplish, and by allowing independent control of performance parameters, you can experiment with optimizing your code with little risk of breaking it.","title":"Tuning"},{"location":"99_Everything_Else/#standard-library","text":"Of course, any good programming language needs a good standard library.","title":"Standard Library"},{"location":"99_Everything_Else/#many-other-things","text":"Serene was intended from the beginning to be a \"small language\", and I plan on limiting the features to only what is necessary. That said, you could probably make a case that many things I haven't listed here are necessary. Programming languages generally seem to \"grow\" over time as people demand more features. The initial Serene compiler will likely start out with a very minimalist featureset, possibly even smaller than what I've shown in the previous sections. And if people start using it, they will almost certainly discover things that aren't possible or ergonomic with the existing features, so the language will need to adapt to address any shortcomings while hopefully keeping its original design intentions intact.","title":"Many Other Things"}]}