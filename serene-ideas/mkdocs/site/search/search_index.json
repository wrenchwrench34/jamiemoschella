{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Serene is a minimalist readable systems programming language designed by Jamie Moschella ( @jammmo ). This site will walk you through the basic design of the language as well as several code examples. Serene is in the very early design stages right now, so there is no working compiler or full documentation yet, but the examples here should give you an idea of the direction that the language is headed. You can also check out the project on GitHub .","title":"Introduction"},{"location":"#introduction","text":"Serene is a minimalist readable systems programming language designed by Jamie Moschella ( @jammmo ). This site will walk you through the basic design of the language as well as several code examples. Serene is in the very early design stages right now, so there is no working compiler or full documentation yet, but the examples here should give you an idea of the direction that the language is headed. You can also check out the project on GitHub .","title":"Introduction"},{"location":"00_What_Is_Unique/","text":"0. What is Unique about Serene? Serene's biggest innovation is its memory management model. In general, most high level programming languages (like JavaScript, Python, and Java) use a tracing garbage collector, while systems programming languages have traditionally relied on manual memory management. Both approaches have their disadvantages: manual memory management is more complex from the programmer's perspective and is prone to small errors that can cause serious bugs, while tracing garbage collectors can introduce runtime overhead and unpredictability that are undesirable for systems programming. In recent years, a third approach has gained popularity: ownership. The idea of ownership, which was pioneered by the language Rust, is that each value is owned by only one variable at a given time. When that variable goes out of scope, the value will be automatically deleted. It allows for safe and predictable memory management without the need for intervention from the programmer or from an additional runtime process. However, for Rust's borrowing system to be as versatile as the extensive feature-set of a language like C++ required Rust to adopt a similarly large and complex range of features and rules, which has led some to say that the language has a \"high learning curve\". Serene takes inspiration from Rust's memory management system, but it aims to make ownership more straightforward. It does this by eliminating something that is a staple of most systems programming languages: Serene doesn't allow you to store references or pointers. There is no global sharing of state whatsoever -- each value is owned by only one variable at a given time, and it is only accessible through that variable . This may seem limiting, but if you imagine a program's memory as simply a large global array, and that a pointer is simply a index into that array, you can start to imagine alternate ways of recreating reference-like behavior without explicit pointers or references. The simplest way, which is adopted in Serene's Region and Handle system, is to split that global array into multiple local arrays, and to pass the arrays and indexes back and forth between functions when data needs to be shared. This effectively simulates region-based memory management. When a Serene object needs to reference another object, it can store an index, or Handle , to the Region that stores the other object. And unlike a local variable with a pointer, which is essentially a locally-stored index to a globally-stored array, both Handles and Regions are local, so no sharing of state is possible without passing parameters. Without pointers or references, program logic is much easier for a reader to follow, as you can clearly see whether any value is being mutated and where. In Serene, function parameters are passed immutably by default, but you can also create a function that will move , copy , or mutate its parameters, and there are keywords at both the definition site and calling site to make this behavior obvious. Serene's ownership model keeps the language simple and readable, while maintaining the low overhead and efficiency that is necessary for systems programming.","title":"0. What is Unique about Serene?"},{"location":"00_What_Is_Unique/#0-what-is-unique-about-serene","text":"Serene's biggest innovation is its memory management model. In general, most high level programming languages (like JavaScript, Python, and Java) use a tracing garbage collector, while systems programming languages have traditionally relied on manual memory management. Both approaches have their disadvantages: manual memory management is more complex from the programmer's perspective and is prone to small errors that can cause serious bugs, while tracing garbage collectors can introduce runtime overhead and unpredictability that are undesirable for systems programming. In recent years, a third approach has gained popularity: ownership. The idea of ownership, which was pioneered by the language Rust, is that each value is owned by only one variable at a given time. When that variable goes out of scope, the value will be automatically deleted. It allows for safe and predictable memory management without the need for intervention from the programmer or from an additional runtime process. However, for Rust's borrowing system to be as versatile as the extensive feature-set of a language like C++ required Rust to adopt a similarly large and complex range of features and rules, which has led some to say that the language has a \"high learning curve\". Serene takes inspiration from Rust's memory management system, but it aims to make ownership more straightforward. It does this by eliminating something that is a staple of most systems programming languages: Serene doesn't allow you to store references or pointers. There is no global sharing of state whatsoever -- each value is owned by only one variable at a given time, and it is only accessible through that variable . This may seem limiting, but if you imagine a program's memory as simply a large global array, and that a pointer is simply a index into that array, you can start to imagine alternate ways of recreating reference-like behavior without explicit pointers or references. The simplest way, which is adopted in Serene's Region and Handle system, is to split that global array into multiple local arrays, and to pass the arrays and indexes back and forth between functions when data needs to be shared. This effectively simulates region-based memory management. When a Serene object needs to reference another object, it can store an index, or Handle , to the Region that stores the other object. And unlike a local variable with a pointer, which is essentially a locally-stored index to a globally-stored array, both Handles and Regions are local, so no sharing of state is possible without passing parameters. Without pointers or references, program logic is much easier for a reader to follow, as you can clearly see whether any value is being mutated and where. In Serene, function parameters are passed immutably by default, but you can also create a function that will move , copy , or mutate its parameters, and there are keywords at both the definition site and calling site to make this behavior obvious. Serene's ownership model keeps the language simple and readable, while maintaining the low overhead and efficiency that is necessary for systems programming.","title":"0. What is Unique about Serene?"},{"location":"01_Functions/","text":"1. Functions Every program in Serene is required to have a main function. Here is a basic example of a main function that prints \"Hello world!\" on a new line. function main () { run printLine( \"Hello world!\" ) } Here, \"Hello world!\" is being passed as a parameter to the printLine function. Let's define another function that takes a parameter and also returns a value. Note that the types of both the parameters and return values must be specified. function invert (b: Bool ) -> Bool { return (not b) }","title":"1. Functions"},{"location":"01_Functions/#1-functions","text":"Every program in Serene is required to have a main function. Here is a basic example of a main function that prints \"Hello world!\" on a new line. function main () { run printLine( \"Hello world!\" ) } Here, \"Hello world!\" is being passed as a parameter to the printLine function. Let's define another function that takes a parameter and also returns a value. Note that the types of both the parameters and return values must be specified. function invert (b: Bool ) -> Bool { return (not b) }","title":"1. Functions"},{"location":"02_Variables_Types_And_Math/","text":"2. Variables, Types, and Math A new variable can be created with either the keyword const (short for \"constant\") or the keyword var (short for \"variable\"). function test1 () { const age: Int = 20 run printLine(age) // age can't be changed here! } function test2 () { var age: Int = 20 run printLine(age) set age = 21 run printLine(age) set age = age + 1 run printLine(age) set age += 1 // same as: set age = age + 1 run printLine(age) } function test3 () { const base = 5 //the type Int is implied here const height = 8 const area: Float = (1/2) * base * height run printLine(area, \" inches\" ) } function test4 () { var name: String = \"Rick Astley\" set name = \"Rickroll\" //strings are mutable run printLine(name) }","title":"2. Variables, Types, and Math"},{"location":"02_Variables_Types_And_Math/#2-variables-types-and-math","text":"A new variable can be created with either the keyword const (short for \"constant\") or the keyword var (short for \"variable\"). function test1 () { const age: Int = 20 run printLine(age) // age can't be changed here! } function test2 () { var age: Int = 20 run printLine(age) set age = 21 run printLine(age) set age = age + 1 run printLine(age) set age += 1 // same as: set age = age + 1 run printLine(age) } function test3 () { const base = 5 //the type Int is implied here const height = 8 const area: Float = (1/2) * base * height run printLine(area, \" inches\" ) } function test4 () { var name: String = \"Rick Astley\" set name = \"Rickroll\" //strings are mutable run printLine(name) }","title":"2. Variables, Types, and Math"},{"location":"03_Mutability_And_Ownership/","text":"3. Mutability and Ownership All values in Serene are owned by a single variable. function middleChar (s: String , mutate c: Char ) { // Find the character at the middle index of a string const length = s.length const middle = Int(length / 2) set c = s[middle] } function removeChar ( mutate s: String , c: Char ) { // Remove all instances of a character in a string var i = 0 while (i < s.length) { if (s[i] == c) { run s.delete(i) } else { set i += 1 } } } function main () { const name = \"Matthew\" var letter = Char( ' ' ) run middleChar(name, mutate letter) var newname = name //copies name run removeChar( mutate newname, c) }","title":"3. Mutability and Ownership"},{"location":"03_Mutability_And_Ownership/#3-mutability-and-ownership","text":"All values in Serene are owned by a single variable. function middleChar (s: String , mutate c: Char ) { // Find the character at the middle index of a string const length = s.length const middle = Int(length / 2) set c = s[middle] } function removeChar ( mutate s: String , c: Char ) { // Remove all instances of a character in a string var i = 0 while (i < s.length) { if (s[i] == c) { run s.delete(i) } else { set i += 1 } } } function main () { const name = \"Matthew\" var letter = Char( ' ' ) run middleChar(name, mutate letter) var newname = name //copies name run removeChar( mutate newname, c) }","title":"3. Mutability and Ownership"},{"location":"04_More_Types/","text":"4. More Types In this section, we will learn about several more complex types that are built into Serene. Optionals Optionals are used to represent values that may or may not exist. Before making use of the value, the language require you to check that the Optional is not None. This is typically done with a match statement or an either statement, which will both be introduced in the next section of this guide. function getFirst (u: String ) -> Optional[Char] { if (u.length > 0) { return u[0] } else { return None } } Arrays An array is a fixed-length sequence elements, where all of the elements are the same type. Indexing an array always returns an Optional, because the index used may be outside of the valid range of indexes. If the index is invalid, the indexing operation will return None. function binarySearch (u: Array [Int], x: Int ) -> Int { var i = u.length / 2 while (True) { if (u[i] < x) { set i = i / 2 } elseif (u[i] > x) { set i = (i + u.length)/2 } else { return i } } } //Where are the Optionals? Vectors An vector is similar to an array, except its length can be changed after creation. Like an array, indexing a vector returns an Option. function binarySearchAndDelete ( mutate u: Array [Int], x: Int ) { var i = u.length / 2 while (True) { if (u[i] < x) { set i = i / 2 } elseif (u[i] > x) { set i = (i + u.length)/2 } else { u.delete!(i) } } } //Where are the Optionals?","title":"4. More Types"},{"location":"04_More_Types/#4-more-types","text":"In this section, we will learn about several more complex types that are built into Serene.","title":"4. More Types"},{"location":"04_More_Types/#optionals","text":"Optionals are used to represent values that may or may not exist. Before making use of the value, the language require you to check that the Optional is not None. This is typically done with a match statement or an either statement, which will both be introduced in the next section of this guide. function getFirst (u: String ) -> Optional[Char] { if (u.length > 0) { return u[0] } else { return None } }","title":"Optionals"},{"location":"04_More_Types/#arrays","text":"An array is a fixed-length sequence elements, where all of the elements are the same type. Indexing an array always returns an Optional, because the index used may be outside of the valid range of indexes. If the index is invalid, the indexing operation will return None. function binarySearch (u: Array [Int], x: Int ) -> Int { var i = u.length / 2 while (True) { if (u[i] < x) { set i = i / 2 } elseif (u[i] > x) { set i = (i + u.length)/2 } else { return i } } } //Where are the Optionals?","title":"Arrays"},{"location":"04_More_Types/#vectors","text":"An vector is similar to an array, except its length can be changed after creation. Like an array, indexing a vector returns an Option. function binarySearchAndDelete ( mutate u: Array [Int], x: Int ) { var i = u.length / 2 while (True) { if (u[i] < x) { set i = i / 2 } elseif (u[i] > x) { set i = (i + u.length)/2 } else { u.delete!(i) } } } //Where are the Optionals?","title":"Vectors"},{"location":"05_Control_Flow/","text":"5. Control Flow So far, we have learned several key components to how programs are structured in Serene. However, it would be hard to implement anything practical with only what we have shown so far, as we haven't shown much of the logic necessary for describing any form of procedure. Here we discuss the control flow constructs that enable us to write practical programs. Conditional Statements A conditional statement (or an if/else statement) allows a program to check a condition and do something different based on the value of that condition. function absoluteValue (x: Int ) { if (x < 0) { return -x } else { return x } } Loops Serene has two looping constructs: For Loops and While Loops. function findMax (u: Vector [Int]) -> Int { var max: Int = INT_MIN for (x in u) { if (x > max) { set max = x } } } function findMax2 (u: Vector [Int]) -> Int { var max: Int = INT_MIN var i: Int = 0 while (i < u.length) { if (u[i] > max) { // Do you need to check if u[i] is None? set max = u[i] } } } Match A Match statement takes a single object as its parameter and it allows you to write multiple paths of execution based on the value of the object. function makeChoice () -> Bool { while (True) { var input = ReadLine() match (input) { \"\" -> continue \"y\", \"Y\" -> return True \"n\", \"N\" -> return False else -> { run printLine( \"Input is invalid, try again\" ) continue } } } } Either Here is an example of using the indexing operator on a Handle . To deal with the Option type that is returned, we use the either construct. either will try to execute the statement in parentheses, and if any part of it returns None , then it will stop executing that statement (in this case, it would stop without mutating currentObject ) and it would instead execute the second statement, after the keyword or . // Assume that the LinkedList struct redirects its subscripting to LinkedList.objects function findTail (u: LinkedList ) -> Handle { either ( var currentObject = u[u.head]) or return None while (True) { var currentIndex = currentObject.next either ( set currentObject = L[currentIndex]) or return currentIndex } } function removeTail ( mutate u: LinkedList ) { either ( var currentObject = u[u.head]) or return //This copies u[u.head] so it might not be efficient while (True) { var currentIndex = currentObject.next either ( set currentObject = u[currentIndex]) or break } run u.delete!(currentIndex) //methods that mutate the object are called with a \"!\" }","title":"5. Control Flow"},{"location":"05_Control_Flow/#5-control-flow","text":"So far, we have learned several key components to how programs are structured in Serene. However, it would be hard to implement anything practical with only what we have shown so far, as we haven't shown much of the logic necessary for describing any form of procedure. Here we discuss the control flow constructs that enable us to write practical programs.","title":"5. Control Flow"},{"location":"05_Control_Flow/#conditional-statements","text":"A conditional statement (or an if/else statement) allows a program to check a condition and do something different based on the value of that condition. function absoluteValue (x: Int ) { if (x < 0) { return -x } else { return x } }","title":"Conditional Statements"},{"location":"05_Control_Flow/#loops","text":"Serene has two looping constructs: For Loops and While Loops. function findMax (u: Vector [Int]) -> Int { var max: Int = INT_MIN for (x in u) { if (x > max) { set max = x } } } function findMax2 (u: Vector [Int]) -> Int { var max: Int = INT_MIN var i: Int = 0 while (i < u.length) { if (u[i] > max) { // Do you need to check if u[i] is None? set max = u[i] } } }","title":"Loops"},{"location":"05_Control_Flow/#match","text":"A Match statement takes a single object as its parameter and it allows you to write multiple paths of execution based on the value of the object. function makeChoice () -> Bool { while (True) { var input = ReadLine() match (input) { \"\" -> continue \"y\", \"Y\" -> return True \"n\", \"N\" -> return False else -> { run printLine( \"Input is invalid, try again\" ) continue } } } }","title":"Match"},{"location":"05_Control_Flow/#either","text":"Here is an example of using the indexing operator on a Handle . To deal with the Option type that is returned, we use the either construct. either will try to execute the statement in parentheses, and if any part of it returns None , then it will stop executing that statement (in this case, it would stop without mutating currentObject ) and it would instead execute the second statement, after the keyword or . // Assume that the LinkedList struct redirects its subscripting to LinkedList.objects function findTail (u: LinkedList ) -> Handle { either ( var currentObject = u[u.head]) or return None while (True) { var currentIndex = currentObject.next either ( set currentObject = L[currentIndex]) or return currentIndex } } function removeTail ( mutate u: LinkedList ) { either ( var currentObject = u[u.head]) or return //This copies u[u.head] so it might not be efficient while (True) { var currentIndex = currentObject.next either ( set currentObject = u[currentIndex]) or break } run u.delete!(currentIndex) //methods that mutate the object are called with a \"!\" }","title":"Either"},{"location":"06_Custom_Types/","text":"6. Custom Types Types in Serene can be defined using the type keyword, as shown below. Serene supports multiple forms of \"compound types\", including structs, enums, and tuples. type Person struct { age: Int , name: String , gender: enum { Male, Female }, nickname: enum { Some (String), None }, } type Point3D tuple { Int, Int, Int } type Address tuple { Int, // House number String, // Street name } type RainbowColors enum { Red, Orange, Yellow, Green, Blue, Purple }","title":"6. Custom Types"},{"location":"06_Custom_Types/#6-custom-types","text":"Types in Serene can be defined using the type keyword, as shown below. Serene supports multiple forms of \"compound types\", including structs, enums, and tuples. type Person struct { age: Int , name: String , gender: enum { Male, Female }, nickname: enum { Some (String), None }, } type Point3D tuple { Int, Int, Int } type Address tuple { Int, // House number String, // Street name } type RainbowColors enum { Red, Orange, Yellow, Green, Blue, Purple }","title":"6. Custom Types"},{"location":"07_Interfaces/","text":"7. Interfaces When writing a function, sometimes you only care about what methods the function arguments support, and not how they're implemented. You may want to write the function in a flexible way so that they can accept any type that implements the correct methods. That can be done with Interfaces. Here is an example of how you can define an Interface. import AddressModule interface Card with ~ struct { returnAddress: String } interface Invitation with ~ struct { date: String , location: Address , numGuests: Int , accepted: Bool } ~ signatures { method send (recipient: Person ), method accept (guests: Int ) } type WeddingInvitation with ~ struct { bride: String , groom: String , struct from Invitation, struct from Card } ~ specifics (implements Invitation) { method send (recipient: Person ) { run recipient.receive( copy self) } method accept (guests: Int ) { set self.accepted = True } method parseLocation (address: String ) from AddressModule } // Interfaces with generics? interface CompareAndIndex(self: type X) with ~ signatures { method lessThan (other: X ) -> bool method greaterThan (other: X ) -> bool subscript get (index: Int ) -> Option(X) } ~ specifics where X: Array [Int] { method lessThan (other: Array [Int]) { for (i = 0, min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] < other[i] } } return self.length < other.length } method lessThan (other: Array [Int]) { for (i = 0, min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] > other[i] } } return self.length > other.length } subscript get (index: Int ) -> Optional[Int] from Index(self: Array [ type X]) }","title":"7. Interfaces"},{"location":"07_Interfaces/#7-interfaces","text":"When writing a function, sometimes you only care about what methods the function arguments support, and not how they're implemented. You may want to write the function in a flexible way so that they can accept any type that implements the correct methods. That can be done with Interfaces. Here is an example of how you can define an Interface. import AddressModule interface Card with ~ struct { returnAddress: String } interface Invitation with ~ struct { date: String , location: Address , numGuests: Int , accepted: Bool } ~ signatures { method send (recipient: Person ), method accept (guests: Int ) } type WeddingInvitation with ~ struct { bride: String , groom: String , struct from Invitation, struct from Card } ~ specifics (implements Invitation) { method send (recipient: Person ) { run recipient.receive( copy self) } method accept (guests: Int ) { set self.accepted = True } method parseLocation (address: String ) from AddressModule } // Interfaces with generics? interface CompareAndIndex(self: type X) with ~ signatures { method lessThan (other: X ) -> bool method greaterThan (other: X ) -> bool subscript get (index: Int ) -> Option(X) } ~ specifics where X: Array [Int] { method lessThan (other: Array [Int]) { for (i = 0, min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] < other[i] } } return self.length < other.length } method lessThan (other: Array [Int]) { for (i = 0, min(self.length, other.length)) { if (self[i] != other[i]) { return self[i] > other[i] } } return self.length > other.length } subscript get (index: Int ) -> Optional[Int] from Index(self: Array [ type X]) }","title":"7. Interfaces"},{"location":"08_Generic_Functions/","text":"8. Generic Functions Serene supports both generic functions and generic types. A generic parameter is specified using the type keyword, like in the example below. function elementInArray ( move elem: type T, arr: Array [ type T]) -> Optional[ type T] { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return None } // Where statement function elementInArray ( move elem: type A, arr: type B) -> type A where type A: Simple , type B: Array [A] { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return None } // Idea: plug in type variable to function instead of value to yield return type? // Potentially some ambiguity/confusion there but definitely useful // Is \"type\" needed everywhere in the signature or only the first time the name is referenced?","title":"8. Generic Functions"},{"location":"08_Generic_Functions/#8-generic-functions","text":"Serene supports both generic functions and generic types. A generic parameter is specified using the type keyword, like in the example below. function elementInArray ( move elem: type T, arr: Array [ type T]) -> Optional[ type T] { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return None } // Where statement function elementInArray ( move elem: type A, arr: type B) -> type A where type A: Simple , type B: Array [A] { for (i = 0, arr.length) { if (arr[i] == elem) { return elem } } return None } // Idea: plug in type variable to function instead of value to yield return type? // Potentially some ambiguity/confusion there but definitely useful // Is \"type\" needed everywhere in the signature or only the first time the name is referenced?","title":"8. Generic Functions"},{"location":"09_Generic_Types/","text":"9. Generic Types We will introduce generic types through an example using Regions and Handles, two commonly used built-in types. Regions and Handles Serene does not have references or pointers. So how does one object refer to another object? The idiom that is most commonly used in Serene is region-based memory management, with the types Region and Handle . A Region is a dynamically-sized block of memory where objects of the same type can be stored. Those objects are accessed using an index, referred to as a Handle . If you have a bunch of objects of the same type that all refer to each other (say, in a data structure like a linked list), then the typical way to handle it is to store all of the objects inside one Region . Then an object can access another object by storing its Handle in one of its fields. The other object would be accessed with an indexing operator, like my_region[my_handle] . Note that the indexing operator returns an Option type here because it is possible that there is no valid object for that handle. Below is a reference implementation of the Region and Handle types. // Potential implementation of the Region and Handle system as a standard library module type Handle with ~ constructor( type MyRegion, index: Int ) { set index = index } ~ struct { index: Int private } ~ friend Region // Handle has two parameters here, but only one is needed for the generic? type Region with ~ constructor( type T) { set vector = Vector[T] type R = typeof(self) } ~ struct { vector: Vector [T] private, } ~ specifics { method add (new_value: T ) -> Handle[R] { run vector.append(NewValue) const handle = Handle(Region, vector.length) return handle } method delete (index_to_delete: Handle [R]) { run vector.pop!(index_to_delete) } subscript get (my_handle: Handle [R]) -> Optional[T] { return vector[my_handle.index] } } // Note that all T's here are the same and they come from the constructor. Need a better way to make that clear...","title":"9. Generic Types"},{"location":"09_Generic_Types/#9-generic-types","text":"We will introduce generic types through an example using Regions and Handles, two commonly used built-in types.","title":"9. Generic Types"},{"location":"09_Generic_Types/#regions-and-handles","text":"Serene does not have references or pointers. So how does one object refer to another object? The idiom that is most commonly used in Serene is region-based memory management, with the types Region and Handle . A Region is a dynamically-sized block of memory where objects of the same type can be stored. Those objects are accessed using an index, referred to as a Handle . If you have a bunch of objects of the same type that all refer to each other (say, in a data structure like a linked list), then the typical way to handle it is to store all of the objects inside one Region . Then an object can access another object by storing its Handle in one of its fields. The other object would be accessed with an indexing operator, like my_region[my_handle] . Note that the indexing operator returns an Option type here because it is possible that there is no valid object for that handle. Below is a reference implementation of the Region and Handle types. // Potential implementation of the Region and Handle system as a standard library module type Handle with ~ constructor( type MyRegion, index: Int ) { set index = index } ~ struct { index: Int private } ~ friend Region // Handle has two parameters here, but only one is needed for the generic? type Region with ~ constructor( type T) { set vector = Vector[T] type R = typeof(self) } ~ struct { vector: Vector [T] private, } ~ specifics { method add (new_value: T ) -> Handle[R] { run vector.append(NewValue) const handle = Handle(Region, vector.length) return handle } method delete (index_to_delete: Handle [R]) { run vector.pop!(index_to_delete) } subscript get (my_handle: Handle [R]) -> Optional[T] { return vector[my_handle.index] } } // Note that all T's here are the same and they come from the constructor. Need a better way to make that clear...","title":"Regions and Handles"},{"location":"10_Modules/","text":"10. Modules It is extremely helpful to be able to use well-tested existing pieces of code to implement common functionality, or to be able to split your own code into multiple files for organization. Modules allow you to do just that. Like most programming languages, Serene is packaged with a standard library that implements many common functions and datatypes so you don't have to implement them yourself. You can use import statements to control what external modules you want to use. Import statements also allow you to import modules that you have created yourself, by using a relative file path to the module's location. Standard Imports import Math import AsyncGUI.window as window Local Imports import local \"lib/MovieReviewTypes.sn\"","title":"10. Modules"},{"location":"10_Modules/#10-modules","text":"It is extremely helpful to be able to use well-tested existing pieces of code to implement common functionality, or to be able to split your own code into multiple files for organization. Modules allow you to do just that. Like most programming languages, Serene is packaged with a standard library that implements many common functions and datatypes so you don't have to implement them yourself. You can use import statements to control what external modules you want to use. Import statements also allow you to import modules that you have created yourself, by using a relative file path to the module's location.","title":"10. Modules"},{"location":"10_Modules/#standard-imports","text":"import Math import AsyncGUI.window as window","title":"Standard Imports"},{"location":"10_Modules/#local-imports","text":"import local \"lib/MovieReviewTypes.sn\"","title":"Local Imports"},{"location":"Linked-List/","text":"Example A: Linked List Here is an example of a singly linked list implementation in Serene: // Linked list of integers type Node( type N) struct { data: Int , next: N , } type LinkedList with ~ struct { nodes: Region (Node), head: Handle , } ~ constructor(first: Int ) { set nodes = Region(Node) type Handle = nodes.Handle set head = nodes.add!(Node(first, None)) } ~ specifics { method addFirst (a: Int ) { set self.head = nodes.add!(Node(a, self.head)) } method addLast (a: Int ) { if (head is None) { set head = nodes.add!(Node(a, None)) } else { var x = nodes[self.head] while (x.next != None) { set x = nodes[x.next] } set x.next = nodes.add!(Node(a, None)) } } method deleteFirst () { if (head is None) return const x = head set head = nodes[head].next run nodes.delete!(x) } method deleteLast () { if (head == None) return var x = nodes[self.head] while (x.next != None) { set x = nodes[x.next] } run nodes.delete!(x) } subscript get (MyHandle: Handle ) -> Optional[Int] { return nodes[MyHandle] } }","title":"Example A: Linked List"},{"location":"Linked-List/#example-a-linked-list","text":"Here is an example of a singly linked list implementation in Serene: // Linked list of integers type Node( type N) struct { data: Int , next: N , } type LinkedList with ~ struct { nodes: Region (Node), head: Handle , } ~ constructor(first: Int ) { set nodes = Region(Node) type Handle = nodes.Handle set head = nodes.add!(Node(first, None)) } ~ specifics { method addFirst (a: Int ) { set self.head = nodes.add!(Node(a, self.head)) } method addLast (a: Int ) { if (head is None) { set head = nodes.add!(Node(a, None)) } else { var x = nodes[self.head] while (x.next != None) { set x = nodes[x.next] } set x.next = nodes.add!(Node(a, None)) } } method deleteFirst () { if (head is None) return const x = head set head = nodes[head].next run nodes.delete!(x) } method deleteLast () { if (head == None) return var x = nodes[self.head] while (x.next != None) { set x = nodes[x.next] } run nodes.delete!(x) } subscript get (MyHandle: Handle ) -> Optional[Int] { return nodes[MyHandle] } }","title":"Example A: Linked List"}]}